# 06. B-Tree , B+Tree

## B-Tree

<img width="363" alt="스크린샷_2022-03-28_오후_2 25 07" src="https://user-images.githubusercontent.com/47092708/160608635-9a857a1b-8ccd-4001-983e-c6a3fc639705.png">

<img width="777" alt="스크린샷_2022-03-28_오후_2 23 20" src="https://user-images.githubusercontent.com/47092708/160608619-db508bc3-5efd-4483-aa22-f64171edfbe4.png">

- 이진트리에서 파생된 트리구조
    - 차이점 1: 하나의 노드가 2개 이상의 데이터를 가질 수 있음
    - 차이점 2: 자식노드도 여러개를 가질 수 있음. → 트리의 높이를 낮추게 됨.
    - 차이점 3: 균형 트리(루트~리프까지 거리가 일정) → 성능이 안정화. INSERT나 DELETE가 일어나도 균형을 유지하도록 되어있지만 갱신작업이 계속 반복되다 보면 인덱스 재구성을 해서 균형을 되찾는 작업이 필요하기도 함.
    
    → 대량의 데이터를 처리하는 검색 구조의 경우 많이 사용함. 블럭 단위로 입출력이 가능해서 효율적임. 많은 데이터 베이스 시스템의 인덱스 저장방법으로 애용되고 있음.
    
- 데이터가 정렬된 상태로 유지되어 있음. → 빠른 데이터 엑세스 가능

### 특징

- 노드의 데이터 수는 2개 이상일 수 있음
- 노드의 데이터 수가 N개이면, 자식 노드의 수는 N+1개여야 함
- 노드에 저장할 수 있는 데이터 수에 따라 M차 B-Tree라고 부름
- 루트 노드를 제외한 모든 노드는 적어도 M/2개의 데이터를 가져야 함
- 노드 내 키는 정렬된 상태여야 함
- 리프 노드로 가는 모든 경로는 길이가 같아야함(균형 트리)

## B+Tree

<img width="584" alt="스크린샷_2022-03-28_오후_2 44 34" src="https://user-images.githubusercontent.com/47092708/160608647-358d4db7-7599-4984-b735-bb0d2b3e869a.png">

- B-tree의 확장버전
    - 브랜치 노드에는 key만 담아두고 data는 담아두지 않음. leaf에 있는 key값을 직접 찾아가는데 사용할 뿐 모든 key값은 leaf 노드에 나열됨. 때문에 부모 노드와 자식 노드가 같은 키 공유가 가능함
    - 리프 노드에만 key와 data 값이 저장될 수 있고, 리프노드들끼리 linked list로 연결되어 있다.

### 장점

- 리프노드에만 데이터가 담겨있기 때문에 메모리를 확보함으로서 더 많은 key값 저장 가능
    - 하나의 노드에 더 많은 key를 담을 수 있음 → 트리의 높이 더 낮아짐
- 풀 스캔시 B-Tree보다 빠름
    - 리프 노드에 데이터가 모두 있기 때문에 한번의 선형탐색만 하면 됨. B-Tree는 모든 노드 확인 필요함

### 단점

- 풀 스캔이 아닐 경우 B-Tree가 빠를 수 있음. (B+Tree는 리프 노드까지 가야 데이터에 접근할 수 있기 떄문)